[
    {
        "theme": "request object",
        "thesises": {
            "common names": "req or request, can be any valid JS identifier",
            "origination": "out of http.IncommingMessage it is the instance of nodejs core object"
        },
        "subjects": {
            "req.params": "array. contains the named route parameters",
            "req.param(name)": "returns named route parameter, or GET/POST params. RECOMMEND TO AVOID!",
            "req.query": "contains querystring params as name/value pairs aka GET params",
            "req.body": "contains POST params. To parse the body content need use middleware",
            "req.route": "contains currently matched route. Uses mainly for debugging",
            "req.cookies/req.signedCookies": "object. contains cookie passed from the client",
            "req.headers": "headers received from the client",
            "req.accepts[types]": "method. to determine whether the client accepts given type(s)",
            "req.ip": "the client's IP address",
            "req.path": "request path only",
            "req.host": "method. get the client's hostname. !!!Should not be used for security purposes!!!",
            "req.xhr": "property. true if origignates for AJAX",
            "req.protocol": "used protocol",
            "req.secure": "property. true if connetcions is secure",
            "req.url/req.originalUrl": "properties. returns path and quesrystring. originalUrl returns the original request",
            "req.acceptLanguages": "method. returns array of preferred languages. Comes from request header"
        }
    },
    {
        "theme": "response object",
        "thesises": {
            "common names": "res, resp or response, can be any valid JS identifier",
            "origination": "out of http.ServerResponse it is the instance of nodejs core object"
        },
        "subjects": {
            "res.status(code)": "sets HTTP status code. Default 200(OK). 404(Not Found), 500(Server Error) or any other should be specified. Not suitable for redirect status codes (30X)",
            "res.set(name, value)": "sets a response header",
            "res.cookie(name, value, [options]), res.clearCookies(name, [options])": "sets or clears cookies",
            "res.redirect([status], url)": "redirects the browser. Default 302(Found). Other redirect codes should be specified",
            "res.send(body), res.send(status, body)": "sends a response body with optional statuse code. Default content-type is text/html. If needs change content-type, before sending of body the header should be changed appropriately by using res.set() method",
            "res.json(json), res.json(status, json)": "sends JSON. Status code is optional",
            "res.jsonp(jsonp), res.jsonp(status, jsonp)": "sends JSONP. Status code is optional",
            "res.type(type)": "sets the Content-Type header. Allow easelly sets a content type. F.e. res.type('text') will set header Content-Type: text/plain. Explicit setting is better!",
            "res.format(object)": "allows send different content depending on the Accept request header. F.i. res.format({'text/plain': 'hi there', 'text/html': '<b>hi there</b>'})",
            "res.attachment([filename]), res.download(path, [filename], [callback])": "set a response header called Content-Disposition to attachment. It is a way to say to a browser to download the content instead render it on a display. res.download - specify a file, res.attachment - sets the header",
            "res.sendFile(path, [options], [callback])": "will read a file specified by path and send it content to the client",
            "res.links(links)": "sets the Links response header. Little use",
            "res.locals, res.render(view, [locals], callback)": "res.locals - object - contains default context for rendering views. res.render - renders view using the configured template engine. res.render don't set status code 200. It shoul be done manually by using res.status(code)"
        }
    },
    {
        "theme": "handlebars",
        "thesises": {},
        "subjects": {
            "comments": "{{! some comment}} // this kinde of comments never be shown at result html",
            "blocks": "provides flow control, conditional execution, extensibility. {{#each data}} inner template {{/each}} - repeat some template with 'data' context. {{#if condition}} template ((/if}} - conditionally shows corresponded template. {{else}}alternative template{{/else}} - show alternative template, if main condition is falsy. {{../outerContext}} - moving up to outer context. 'if' and 'each' both are have optional 'else' block. {{#unless context}}Template{{/unless}} - will be executed when the 'context' is falsy. {{.}} - refer to the current context (could be used with #each). {{./foo}} - to get properties of 'foo' helper",
            "usingNotes": "when handlebars required it needs initialize: .create({defaultLayout: 'main', extname: '.hbs'}). Here 'defaultLayout' - option to specify name of core layout which is 'main', 'extname' - name of extensions for template files. handlebars look for templates in views/layouts/*.handlebars. If layout is not need it can be rendered this way: res.render('foo', {layout: null}). If it needs to use different template (not default) it can be specified this way: res.render('foo', {layout: 'microsite'}) - template will be picked from views/layout/microsite.handlebars",
            "partials": "{{> somePartial}} - the sign '>' tells handlebars that needs to use partials. Using subdirectories is supported - {{> somePartial/subdirectory}}",
            "sections": "Custom realization. See meadowlark.js const handlebars = require('express3-handlebars').create(...)"
        }
    },
    {
        "theme": "setting cookies",
        "thesises": {},
        "subjects": {
            "domain": "controls the domain the cookies associated with",
            "path": "controls the path this cookies apply to. If path is '/' - the cookie will apply to all site, if '/foo' - will apply to foo page and all consequent pages",
            "maxAge": "specifies how long the cookie will be alive (millisecs). When the option omits the cookie will be deleted right after browser will be closed",
            "secure": "cookie sents only over HTTPS connection",
            "httpOnly": "cookie will be modified only by the server. Prevent XSS attacks",
            "signed": "set to true to sign this cookie. Makes it available in res.signedCookies. If cookies have been signed the server rejects any attemptions to temper them and set its original value"
        }
    },
    {
        "theme": "express-session",
        "thesises": ["The middleware accepts the configuration object with options. Make setting cookies very simple"],
        "subjects": {
            "key": "the name of the cookie that will store the unique session identifier. Default - connect.sid",
            "store": "An instance of a session store. Default - an instance of MemoryStore",
            "cookie": "cookie settings for the session cookie (path, domain, secure, etc.)"
            
        }
    },
    {
        "theme": "middleware",
        "thesises": ["it is way to encapsulate functionality"],
        "subjects": {
            "middleware": "the function that takes three args: req obj, res obj and 'next' function",
            "pipeline": "functionality to execute middleware in appropreate order. Pipelines pass the result execution of one middleware into next middleware. app.use() - add the middleware into the pipeline. The last middleware is so called 'catch all' handler it usually return 404 status code(Not Found). To terminate pipeline a middleware shouldn't call next() function",
            "route handlers": "It is app.VERB f.i. app.get, app.post etc. To handle any HTTP verb use app.all(). Route handlers take some parameters. The first required parameter is path. The route whitch match any route is /*. Middleware also can take path as the first optional parameter. If it is omitted, it will match any path. Route handlers and middleware take a callback function that takes 2, 3 or 4 parameters. If 2 or 3 parameters - first two is req and res, third is next fn(). If 4 - the first is error object. If the next fn hasn't been called pipeline is terminated. Then middleware should send a response (res.send, res.json, res.remder, etc.) otherwise the client will hang. If send a response and call next fn() in the same time it will send the response to a client and pass data to the pipeline, but other sent responses will be ignored",
            "route handler's first parameter": "It is required parameter",
            "common middlewares": {
                "preface": "Oftentimes middlewares should be bundled with Express. It needs to properly get middleware. The module 'connect' solve this problem. First, it needs to be installed 'npm i connect', then it should be availbale across the app: 'const connect = require('connect');'",
                "basicAuth": "app.use(connect.basicAuth)(); Provides basic access authorization. Provides ONLY the basic security, prforms ONLY over HTTPS. This can be used only when needs smth very quick and easy and used HTTPS",
                "body-parser": "app.use(require(body-parser)()); Parses request's body to JSON and urlencoded",
                "json": "see body-parser. Parses JSON-encoded bodies. Needs if API expects JSON-encoded body",
                "urlencoded": "Parses request bodies with media-type application/x-www-form-urlencoded. The Most common way to handle forms and AJAX request",
                "multipart": "Deprecated!!! Use busboy or formidable",
                "compress": "app.use(connect.compress); Compresses response data with gzip. Uses on slow conncections or sending to mobile. This should be linked before any responses. Debugging aor logging middlewares can be connected before",
                "cookie-parser": "npm i cookie-parser; app.use(require('cookie-parser')(secret goes here)); Provides cookie support",
                "cookie-session": "npm i cookie-session; app.use(require(cookie-session)()); Provides cookie-storage session support. Not so good solution. Should be connected after cookie-parser",
                "express-session": "npm i express-session; app.use(require(express-session)()); Provides session ID stored in a cookie. Store ID in a memory, not suitable for production. Can be configured to use database",
                "csurf": "npm i csurf; app.use(require(csurf)()); Provides protection from CSRF attacks. Uses sessuins, must be linked after express-session MDWR.",
                "directory": "app.use(connect.directory()); Provides directory listing support for static files.",
                "errorhandler": "npm i errorhandler; app.use(require(errorhandler)()); Provides stack trace and error messages to client. Not recommended for using in production",
                "static-favicon": "npm i static-favicon; app.use(require(static-favicon)(path to the favicon)); Can be changed with favicon.ico in the root of a project. Provides better performance, allow name favicon file in different way. The MDWR should be registered very high in MDWR stack",
                "morgan": "npm i morgan; app.use(require(morgan)()); Provides automated logging support",
                "method-override": "npm i method-override; app.use(require(method-override)()); Provides support for the x-http-method-override request header.",
                "query": "Parses the querystring and makes it available as the query property on the request object. Express adds it implicitly.",
                "response-time": "npm i response-time; app.use(require(response-time)()); Adds the x-respone-time header to the response in msec. Using when do preformance tuning",
                "static": "app.use(express.static(path to static files)()); Provides support for serving static (public) files. Can be linked multiple times",
                "vhost": "npm i vhost; const vhost = require(vhost); Helps manage subdomains"
            }
        }
    }
]